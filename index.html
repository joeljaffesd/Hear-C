<!doctype html>
<html lang="en-us">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
    <title>Hear-C: Browser-Based C++ Audio Development</title>
    <!-- Favicon -->
    <link rel="icon" href="logo.ico" type="image/x-icon">
    <link rel="shortcut icon" href="logo.ico" type="image/x-icon">
    <!-- Monaco Editor -->
    <script src="https://unpkg.com/monaco-editor@0.44.0/min/vs/loader.js"></script>
    <!-- Main application styles -->
    <link rel="stylesheet" href="styles.css">
  </head>
  <body>
    <!-- Main IDE Layout inspired by Faust IDE -->
    <div class="ide-layout">
      <!-- Header -->
      <div class="header">
        <div class="header-logo">
          <img src="logo.ico" alt="Hear-C Logo" class="logo-icon">
        </div>
        <h1>Hear-C: Browser-Based C++ Audio Development</h1>
        <a href="https://github.com/joeljaffesd/Hear-C" target="_blank" class="github-link" title="View on GitHub">
          <svg class="github-icon" viewBox="0 0 16 16" width="24" height="24" fill="currentColor">
            <path d="M8 0c4.42 0 8 3.58 8 8 0 3.54-2.29 6.53-5.47 7.59-.4-.07-.55-.17-.55-.38 0-.19.01-.82.01-1.49 2.01.37 2.53-.49 2.69-.94.09-.23.48-.94.82-1.13.28-.15.68-.52-.01-.53-.63-.01-1.08.58-1.23.82-.72 1.21-1.87.87-2.33.66-.07-.52-.28-.87-.51-1.07 1.78-.2 3.64-.89 3.64-3.95 0-.87-.31-1.59-.82-2.15.08-.2.36-1.02-.08-2.12 0 0-.67-.21-2.2.82-.64-.18-1.32-.27-2-.27-.68 0-1.36.09-2 .27-1.53-1.03-2.2-.82-2.2-.82-.44 1.1-.16 1.92-.08 2.12-.51.56-.82 1.28-.82 2.15 0 3.06 1.86 3.75 3.64 3.95-.23.2-.44.55-.51 1.07-.46.21-1.61.55-2.33-.66-.15-.24-.6-.83-1.23-.82-.67.01-.27.38.01.53.34.21.73.9.82 1.13.16.45.68 1.31 2.69.94 0 .67.01 1.3.01 1.49 0 .21-.15.31-.55.38C2.29 14.53 0 11.54 0 8c0-4.42 3.58-8 8-8z"/>
          </svg>
        </a>
      </div>
      
      <!-- Main Content Area -->
      <div class="main-content">
        <!-- Center: Code Editor -->
        <div class="editor-section">
          <div class="editor-header">
            <div class="editor-title">user.h</div>
            <div class="editor-status" id="editor-status">Ready</div>
          </div>
          <div id="monaco-editor"></div>
        </div>
        
        <!-- Right Panel: Controls -->
        <div class="right-panel">
          <div class="panel-section">
            <h3>Build & Run</h3>
            <div class="control-group">
              <button id="saveButton" class="panel-button save" type="button">
                üíæ Save
              </button>
              <button id="rebuildButton" class="panel-button build" disabled>
                üî® Build & Run
              </button>
              <button id="resetButton" class="panel-button reset" type="button">
                üîÑ Reset to Default
              </button>
            </div>
          </div>
          
          <div class="panel-section">
            <h3>Audio Control</h3>
            <div class="control-group">
              <button id="startAudio" class="panel-button audio" disabled>
                ‚ñ∂Ô∏è Start Audio
              </button>
            </div>
          </div>
          
        </div>
      </div>
      
      <!-- Bottom Panel: Console Output -->
      <div class="bottom-panel">
        <div class="console-header">
          <h3>Console Output</h3>
          <div class="console-controls">
            <button id="clearConsole" class="console-button">üóëÔ∏è Clear</button>
          </div>
        </div>
        <div class="console-content">
          <textarea id="output" readonly placeholder="Build output and messages will appear here..."></textarea>
        </div>
      </div>
    </div>

    <!-- Error display container for compilation errors -->
    <div id="error-container">
      <div class="error-header">
        <span>Compilation Errors</span>
        <button class="error-close" id="error-close" title="Close error panel">√ó</button>
      </div>
      <div class="error-content" id="error-content"></div>
    </div>

    <!-- Hidden Emscripten Elements -->
    <div class="emscripten" style="display: none;">
      <div id="status">Downloading...</div>
      <progress value="0" max="100" id="progress" hidden></progress>  
      <canvas id="canvas" oncontextmenu="event.preventDefault()" tabindex=-1></canvas>
    </div>

    <script type='text/javascript'>
      var statusElement = document.getElementById('status');
      var progressElement = document.getElementById('progress');
      var outputElement = document.getElementById('output');
      var audioContext = null;
      var audioStarted = false;

      var Module = {
        preRun: [],
        postRun: [],  // Change this to an array instead of a function
        print: (function() {
          outputElement.value = ''; // Clear output on start
          return function(text) {
            if (arguments.length > 1) text = Array.prototype.slice.call(arguments).join(' ');
            console.log(text);
            outputElement.value += text + "\n";
            outputElement.scrollTop = outputElement.scrollHeight;
          };
        })(),
        canvas: (function() {
          var canvas = document.getElementById('canvas');
          canvas.addEventListener("webglcontextlost", function(e) { alert('WebGL context lost. You will need to reload the page.'); e.preventDefault(); }, false);
          return canvas;
        })(),
        setStatus: function(text) {
          if (!Module.setStatus.last) Module.setStatus.last = { time: Date.now(), text: '' };
          if (text === Module.setStatus.last.text) return;
          var m = text.match(/([^(]+)\((\d+(\.\d+)?)\/(\d+)\)/);
          var now = Date.now();
          if (m && now - Module.setStatus.last.time < 30) return; // if this is a progress update, skip it if too soon
          Module.setStatus.last.time = now;
          Module.setStatus.last.text = text;
          if (m) {
            text = m[1];
            progressElement.value = parseInt(m[2])*100;
            progressElement.max = parseInt(m[4])*100;
            progressElement.hidden = false;
          } else {
            progressElement.value = null;
            progressElement.max = null;
            progressElement.hidden = true;
            
            // Enable buttons when status indicates loading is complete
            if (text === 'All downloads complete.') {
              console.log("Enabling audio and rebuild buttons");
              const audioButton = document.getElementById('startAudio');
              const rebuildButton = document.getElementById('rebuildButton');
              if (audioButton) {
                audioButton.disabled = false;
              }
              if (rebuildButton) {
                rebuildButton.disabled = false;
              }
            }
          }
          statusElement.innerHTML = text;
        },
        totalDependencies: 0,
        monitorRunDependencies: function(left) {
          this.totalDependencies = Math.max(this.totalDependencies, left);
          Module.setStatus(left ? 'Preparing... (' + (this.totalDependencies-left) + '/' + this.totalDependencies + ')' : 'All downloads complete.');
        }
      };
      

      
      Module.setStatus('Downloading...');
      

      

      
      window.onerror = function() {
        Module.setStatus('Exception thrown, see JavaScript console');
        Module.setStatus = function(text) {
          if (text) console.error('[post-exception status] ' + text);
        };
      };

      // Monaco Editor Setup
      let editor;
      let originalCode = '';
      let editorActive = false; // Track if editor is active
      const STORAGE_KEY = 'hear_c_user_code';
      const DEFAULT_CODE_KEY = 'hear_c_default_code';
      
      // Default user.h code (embedded for client-side operation)
      const DEFAULT_USER_CODE = `#ifndef USER_H
#define USER_H

/*
NOTE: SAMPLE_RATE, BUFFER_SIZE, and CHANNELS macros come pre-defined
*/

// object definition
class SinOsc {
private:
  float mPhase = 0.f; 
  float mSampleRate = 0.f;
  float mFrequency = 440.f;

public:
  SinOsc() = delete;
  SinOsc(float sampleRate) {
    this->mSampleRate = sampleRate;
  }

  float freq() { return mFrequency; }
  void freq(float newFreq) { this->mFrequency = newFreq; }

  float processSample() {
    mPhase += 2.0f * M_PI * mFrequency / mSampleRate;
    if (mPhase > 2.0f * M_PI) {
      mPhase -= 2.0f * M_PI;  // Keep phase in the [0, 2œÄ] range
    }
    return std::sin(mPhase);
  }

  float operator()() {
    return this->processSample();
  }
};

// global instance of object
SinOsc mOsc{SAMPLE_RATE};

// init function, called once when app starts
void init() { 
  std::cout << "Init called!" << std::endl;
  mOsc.freq(220.f);
}

// per-sample callback, no input (yet)
// this must be defined, or compilation will fail
float nextSample() {
  return mOsc();
}

#endif`;

      // Initialize the Monaco editor after the page loads
      window.addEventListener('load', function() {
        // Configure Monaco loader
        require.config({ 
          paths: { 
            'vs': 'https://unpkg.com/monaco-editor@0.44.0/min/vs' 
          } 
        });
        
        // Load Monaco Editor
        require(['vs/editor/editor.main'], function() {
          // Create Monaco editor instance
          editor = monaco.editor.create(document.getElementById('monaco-editor'), {
            value: '',
            language: 'cpp',
            theme: 'vs-dark',
            fontSize: 14,
            lineNumbers: 'on',
            roundedSelection: false,
            scrollBeyondLastLine: false,
            minimap: {
              enabled: true
            },
            automaticLayout: true,
            tabSize: 2,
            insertSpaces: true,
            wordWrap: 'on',
            bracketPairColorization: {
              enabled: true
            },
            suggest: {
              enabled: true
            },
            quickSuggestions: {
              other: true,
              comments: true,
              strings: true
            }
          });

          // Handle window resize and zoom changes
          let resizeTimeout;
          window.addEventListener('resize', () => {
            clearTimeout(resizeTimeout);
            resizeTimeout = setTimeout(() => {
              if (editor) {
                editor.layout();
              }
            }, 100);
          });

          // Load the source code (from localStorage or server default)
          loadSourceCode();

          // Handle editor focus events
          editor.onDidFocusEditorWidget(() => {
            editorActive = true;
            console.log('Editor focused, keyboard input directed to Monaco');
            
            // Pause emscripten's keyboard events
            if (Module.canvas) {
              Module.canvas.blur();
            }
          });
          
          editor.onDidBlurEditorWidget(() => {
            editorActive = false;
            console.log('Editor blurred, keyboard input restored to canvas');
            
            // Restore focus to canvas for SDL keyboard events
            if (Module.canvas) {
              Module.canvas.focus();
            }
          });
          
          // Add Ctrl+S keyboard shortcut for saving
          editor.addCommand(monaco.KeyMod.CtrlCmd | monaco.KeyCode.KeyS, function() {
            saveSourceCode();
          });
          
          console.log('Monaco Editor initialized successfully');
        });
        
        // Manually blur the canvas when clicking on the editor
        document.getElementById('monaco-editor').addEventListener('mousedown', function(e) {
          if (Module.canvas) {
            Module.canvas.blur();
          }
        });
      });

      // Function to load the source code (localStorage first, then embedded default)
      function loadSourceCode() {
        // Try to load from localStorage first
        const savedCode = localStorage.getItem(STORAGE_KEY);
        
        if (savedCode) {
          // Use saved code from localStorage
          console.log('Loading code from localStorage');
          originalCode = savedCode;
          if (editor) {
            editor.setValue(savedCode);
          }
          return;
        }
        
        // No saved code, use embedded default code
        console.log('Loading embedded default code');
        originalCode = DEFAULT_USER_CODE;
        if (editor) {
          editor.setValue(DEFAULT_USER_CODE);
        }
        // Store the default code for reference
        localStorage.setItem(DEFAULT_CODE_KEY, DEFAULT_USER_CODE);
        console.log('Default source code loaded from embedded code');
      }

      // Function to save the source code to localStorage
      function saveSourceCode() {
        const code = editor.getValue();
        
        try {
          // Save to localStorage
          localStorage.setItem(STORAGE_KEY, code);
          originalCode = code;
          
          console.log('Source code saved to localStorage');
          
          // Show success message
          const saveButton = document.getElementById('saveButton');
          const originalText = saveButton.textContent;
          saveButton.textContent = "Saved ‚úì";
          setTimeout(() => {
            saveButton.textContent = originalText;
          }, 1500);
          
        } catch (error) {
          console.error('Error saving to localStorage:', error);
          alert('Failed to save code to browser storage. Your browser may have storage restrictions.');
        }
      }

      // Initialize UI on load
      window.addEventListener('load', function() {
        updateEditorStatus('Ready');
        
        // Handle clear console button
        document.getElementById('clearConsole').addEventListener('click', function(event) {
          event.preventDefault();
          document.getElementById('output').value = '';
          updateEditorStatus('Console cleared');
          setTimeout(() => {
            updateEditorStatus('Ready');
          }, 2000);
        });

        // Handle error close button
        document.getElementById('error-close').addEventListener('click', function(event) {
          event.preventDefault();
          document.getElementById('error-container').classList.remove('visible');
        });

        // Handle the save button click
        document.getElementById('saveButton').addEventListener('click', function(event) {
          event.preventDefault();
          saveSourceCode();
        });

        // Handle the reset button click
        document.getElementById('resetButton').addEventListener('click', function(event) {
          event.preventDefault();
          if (confirm('Reset to default code? This will lose your current changes.')) {
            resetToDefault();
          }
        });

        // Handle the audio button (start/stop)
        document.getElementById('startAudio').addEventListener('click', function(event) {
          event.preventDefault();
          event.stopPropagation();
          
          if (!audioStarted) {
            // START AUDIO
            try {
              window.AudioContext = window.AudioContext || window.webkitAudioContext;
              audioContext = new AudioContext();
              
              if (audioContext.state === 'suspended') {
                audioContext.resume();
              }
              
              window.SDL2 = window.SDL2 || {};
              window.SDL2.audioContext = audioContext;
              
              // Call the WebAssembly startAudio function
              if (typeof Module !== 'undefined' && Module._startAudio) {
                console.log("Calling WebAssembly startAudio function");
                Module._startAudio();
              } else {
                console.warn("WebAssembly startAudio function not available");
              }
              
              audioStarted = true;
              document.getElementById('startAudio').textContent = '‚è∏Ô∏è Stop Audio';
              console.log("Audio context started and WebAssembly audio initiated");
            } catch (error) {
              console.error("Error starting audio:", error);
              alert("Error starting audio. Check browser console for details.");
            }
          } else {
            // STOP AUDIO
            try {
              // Call the WebAssembly stopAudio function
              if (typeof Module !== 'undefined' && Module._stopAudio) {
                console.log("Calling WebAssembly stopAudio function");
                Module._stopAudio();
              } else {
                console.warn("WebAssembly stopAudio function not available");
              }
              
              if (audioContext) {
                audioContext.close();
                audioContext = null;
              }
              
              audioStarted = false;
              document.getElementById('startAudio').textContent = '‚ñ∂Ô∏è Start Audio';
              console.log("Audio stopped and WebAssembly audio terminated");
            } catch (error) {
              console.error("Error stopping audio:", error);
            }
          }
        });

        // Handle the rebuild button click
        document.getElementById('rebuildButton').addEventListener('click', function(event) {
          event.preventDefault();
          rebuildFromBrowser();
        });
      });
      
      // Function to reset code to default
      function resetToDefault() {
        // Clear saved code from localStorage
        localStorage.removeItem(STORAGE_KEY);
        
        // Use embedded default code
        if (editor) {
          editor.setValue(DEFAULT_USER_CODE);
          // Cache the default code for future use
          localStorage.setItem(DEFAULT_CODE_KEY, DEFAULT_USER_CODE);
          console.log('Code reset to embedded default');
          updateEditorStatus('Reset to default');
          setTimeout(() => {
            updateEditorStatus('Ready');
          }, 2000);
        } else {
          console.error('Editor not available');
          updateEditorStatus('Reset failed', true);
          setTimeout(() => {
            updateEditorStatus('Ready');
          }, 3000);
        }
      }



      // Function to update editor status
      function updateEditorStatus(message, isError = false) {
        const statusElement = document.getElementById('editor-status');
        if (statusElement) {
          statusElement.textContent = message;
          statusElement.style.color = isError ? '#ff7b72' : '#4ec9b0';
        }
      }

      // Update status messages throughout the application
      function updateBuildStatus() {
        updateEditorStatus('Building...', false);
      }

      // Enhanced error display
      function showError(errorMessage) {
        updateEditorStatus('Build failed', true);
        
        const errorContainer = document.getElementById('error-container');
        const errorContent = document.getElementById('error-content');
        
        errorContainer.classList.add('visible');
        errorContent.innerHTML = errorMessage.replace(/\n/g, '<br>');
        
        // Auto-hide after 10 seconds
        setTimeout(() => {
          errorContainer.classList.remove('visible');
        }, 10000);
      }

      // Function to handle rebuild from browser
      function rebuildFromBrowser() {
        const rebuildButton = document.getElementById('rebuildButton');
        
        // Store current scroll position
        const scrollPosition = window.scrollY;
        
        console.log("Rebuild button clicked");
        
        // Save the current code first
        console.log("Auto-saving code before build...");
        saveSourceCode();
        
        rebuildButton.disabled = true;
        rebuildButton.textContent = "Building...";
        updateEditorStatus('Saving & building...', false);
        
        // Hide any previous error display
        const errorContainer = document.getElementById('error-container');
        if (errorContainer) {
          errorContainer.classList.remove('visible');
        }
        
        // Get the current code from the editor
        const currentCode = editor.getValue();
        
        // Make a request to the rebuild server with the current code
        fetch('/rebuild', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({ 
            rebuild: true,
            code: currentCode 
          }),
        })
        .then(response => response.json())
        .then(data => {
          console.log("Rebuild response:", data);
          
          if (data.success) {
            // Build successful
            updateEditorStatus('Build successful! Refreshing...', false);
            alert("Build successful! Refreshing page...");
            // Reload the page to get the new build
            setTimeout(() => {
              window.location.reload();
            }, 1000);
          } else {
            // Build failed - display errors
            console.error("Build failed:", data.error);
            updateEditorStatus('Build failed', true);
            
            // Show error container if available
            if (errorContainer) {
              const errorContent = document.getElementById('error-content');
              if (errorContent) {
                // Clear previous errors
                errorContent.innerHTML = '';
                
                // Add error details
                if (data.errorDetails && data.errorDetails.length) {
                  data.errorDetails.forEach(error => {
                    const errorLine = document.createElement('div');
                    errorLine.className = 'error-line error';
                    errorLine.textContent = error;
                    errorContent.appendChild(errorLine);
                  });
                } else if (data.stderr) {
                  // If no parsed errors, show raw stderr
                  const stderrLines = data.stderr.split('\n');
                  stderrLines.forEach(line => {
                    const errorLine = document.createElement('div');
                    if (line.includes('error:')) {
                      errorLine.className = 'error-line error';
                    } else if (line.includes('warning:')) {
                      errorLine.className = 'error-line warning';
                    } else {
                      errorLine.className = 'error-line';
                    }
                    errorLine.textContent = line;
                    errorContent.appendChild(errorLine);
                  });
                }
                
                // Make the error container visible
                errorContainer.classList.add('visible');
              }
            }
            
            // Update button
            rebuildButton.textContent = "‚öíÔ∏è Build & Run";
          }
        })
        .catch(error => {
          console.error("Error during rebuild:", error);
          updateEditorStatus('Build error', true);
          alert("Error during rebuild. Make sure the rebuild server is running.");
          rebuildButton.textContent = "‚öíÔ∏è Build & Run";
        })
        .finally(() => {
          // Restore scroll position
          window.scrollTo({
            top: scrollPosition,
            behavior: 'instant'
          });
          
          setTimeout(() => {
            rebuildButton.disabled = false;
            if (rebuildButton.textContent === "Building...") {
              rebuildButton.textContent = "‚öíÔ∏è Build & Run";
            }
          }, 3000);
        });
      }


    </script>
    {{{ SCRIPT }}}
  </body>
</html>